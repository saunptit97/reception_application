// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'presenting_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$PresentingEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() showMessage,
    required TResult Function(File file) speechToText,
    required TResult Function(String audio, String language) textToSpeech,
    required TResult Function() syncSensorStatus,
    required TResult Function(List<PositionEntity> positions) initWaypoints,
    required TResult Function() continueTask,
    required TResult Function() cancelTask,
    required TResult Function() pauseTask,
    required TResult Function() nextTask,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? showMessage,
    TResult? Function(File file)? speechToText,
    TResult? Function(String audio, String language)? textToSpeech,
    TResult? Function()? syncSensorStatus,
    TResult? Function(List<PositionEntity> positions)? initWaypoints,
    TResult? Function()? continueTask,
    TResult? Function()? cancelTask,
    TResult? Function()? pauseTask,
    TResult? Function()? nextTask,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? showMessage,
    TResult Function(File file)? speechToText,
    TResult Function(String audio, String language)? textToSpeech,
    TResult Function()? syncSensorStatus,
    TResult Function(List<PositionEntity> positions)? initWaypoints,
    TResult Function()? continueTask,
    TResult Function()? cancelTask,
    TResult Function()? pauseTask,
    TResult Function()? nextTask,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ShowMessage value) showMessage,
    required TResult Function(SpeeckToText value) speechToText,
    required TResult Function(TextToSpeech value) textToSpeech,
    required TResult Function(SyncSensorStatus value) syncSensorStatus,
    required TResult Function(OnInitWaypoints value) initWaypoints,
    required TResult Function(OnContinueTask value) continueTask,
    required TResult Function(OnCancelTask value) cancelTask,
    required TResult Function(OnPauseTask value) pauseTask,
    required TResult Function(OnNextTask value) nextTask,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ShowMessage value)? showMessage,
    TResult? Function(SpeeckToText value)? speechToText,
    TResult? Function(TextToSpeech value)? textToSpeech,
    TResult? Function(SyncSensorStatus value)? syncSensorStatus,
    TResult? Function(OnInitWaypoints value)? initWaypoints,
    TResult? Function(OnContinueTask value)? continueTask,
    TResult? Function(OnCancelTask value)? cancelTask,
    TResult? Function(OnPauseTask value)? pauseTask,
    TResult? Function(OnNextTask value)? nextTask,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ShowMessage value)? showMessage,
    TResult Function(SpeeckToText value)? speechToText,
    TResult Function(TextToSpeech value)? textToSpeech,
    TResult Function(SyncSensorStatus value)? syncSensorStatus,
    TResult Function(OnInitWaypoints value)? initWaypoints,
    TResult Function(OnContinueTask value)? continueTask,
    TResult Function(OnCancelTask value)? cancelTask,
    TResult Function(OnPauseTask value)? pauseTask,
    TResult Function(OnNextTask value)? nextTask,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PresentingEventCopyWith<$Res> {
  factory $PresentingEventCopyWith(
          PresentingEvent value, $Res Function(PresentingEvent) then) =
      _$PresentingEventCopyWithImpl<$Res, PresentingEvent>;
}

/// @nodoc
class _$PresentingEventCopyWithImpl<$Res, $Val extends PresentingEvent>
    implements $PresentingEventCopyWith<$Res> {
  _$PresentingEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ShowMessageImplCopyWith<$Res> {
  factory _$$ShowMessageImplCopyWith(
          _$ShowMessageImpl value, $Res Function(_$ShowMessageImpl) then) =
      __$$ShowMessageImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ShowMessageImplCopyWithImpl<$Res>
    extends _$PresentingEventCopyWithImpl<$Res, _$ShowMessageImpl>
    implements _$$ShowMessageImplCopyWith<$Res> {
  __$$ShowMessageImplCopyWithImpl(
      _$ShowMessageImpl _value, $Res Function(_$ShowMessageImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ShowMessageImpl implements ShowMessage {
  const _$ShowMessageImpl();

  @override
  String toString() {
    return 'PresentingEvent.showMessage()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ShowMessageImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() showMessage,
    required TResult Function(File file) speechToText,
    required TResult Function(String audio, String language) textToSpeech,
    required TResult Function() syncSensorStatus,
    required TResult Function(List<PositionEntity> positions) initWaypoints,
    required TResult Function() continueTask,
    required TResult Function() cancelTask,
    required TResult Function() pauseTask,
    required TResult Function() nextTask,
  }) {
    return showMessage();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? showMessage,
    TResult? Function(File file)? speechToText,
    TResult? Function(String audio, String language)? textToSpeech,
    TResult? Function()? syncSensorStatus,
    TResult? Function(List<PositionEntity> positions)? initWaypoints,
    TResult? Function()? continueTask,
    TResult? Function()? cancelTask,
    TResult? Function()? pauseTask,
    TResult? Function()? nextTask,
  }) {
    return showMessage?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? showMessage,
    TResult Function(File file)? speechToText,
    TResult Function(String audio, String language)? textToSpeech,
    TResult Function()? syncSensorStatus,
    TResult Function(List<PositionEntity> positions)? initWaypoints,
    TResult Function()? continueTask,
    TResult Function()? cancelTask,
    TResult Function()? pauseTask,
    TResult Function()? nextTask,
    required TResult orElse(),
  }) {
    if (showMessage != null) {
      return showMessage();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ShowMessage value) showMessage,
    required TResult Function(SpeeckToText value) speechToText,
    required TResult Function(TextToSpeech value) textToSpeech,
    required TResult Function(SyncSensorStatus value) syncSensorStatus,
    required TResult Function(OnInitWaypoints value) initWaypoints,
    required TResult Function(OnContinueTask value) continueTask,
    required TResult Function(OnCancelTask value) cancelTask,
    required TResult Function(OnPauseTask value) pauseTask,
    required TResult Function(OnNextTask value) nextTask,
  }) {
    return showMessage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ShowMessage value)? showMessage,
    TResult? Function(SpeeckToText value)? speechToText,
    TResult? Function(TextToSpeech value)? textToSpeech,
    TResult? Function(SyncSensorStatus value)? syncSensorStatus,
    TResult? Function(OnInitWaypoints value)? initWaypoints,
    TResult? Function(OnContinueTask value)? continueTask,
    TResult? Function(OnCancelTask value)? cancelTask,
    TResult? Function(OnPauseTask value)? pauseTask,
    TResult? Function(OnNextTask value)? nextTask,
  }) {
    return showMessage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ShowMessage value)? showMessage,
    TResult Function(SpeeckToText value)? speechToText,
    TResult Function(TextToSpeech value)? textToSpeech,
    TResult Function(SyncSensorStatus value)? syncSensorStatus,
    TResult Function(OnInitWaypoints value)? initWaypoints,
    TResult Function(OnContinueTask value)? continueTask,
    TResult Function(OnCancelTask value)? cancelTask,
    TResult Function(OnPauseTask value)? pauseTask,
    TResult Function(OnNextTask value)? nextTask,
    required TResult orElse(),
  }) {
    if (showMessage != null) {
      return showMessage(this);
    }
    return orElse();
  }
}

abstract class ShowMessage implements PresentingEvent {
  const factory ShowMessage() = _$ShowMessageImpl;
}

/// @nodoc
abstract class _$$SpeeckToTextImplCopyWith<$Res> {
  factory _$$SpeeckToTextImplCopyWith(
          _$SpeeckToTextImpl value, $Res Function(_$SpeeckToTextImpl) then) =
      __$$SpeeckToTextImplCopyWithImpl<$Res>;
  @useResult
  $Res call({File file});
}

/// @nodoc
class __$$SpeeckToTextImplCopyWithImpl<$Res>
    extends _$PresentingEventCopyWithImpl<$Res, _$SpeeckToTextImpl>
    implements _$$SpeeckToTextImplCopyWith<$Res> {
  __$$SpeeckToTextImplCopyWithImpl(
      _$SpeeckToTextImpl _value, $Res Function(_$SpeeckToTextImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? file = null,
  }) {
    return _then(_$SpeeckToTextImpl(
      null == file
          ? _value.file
          : file // ignore: cast_nullable_to_non_nullable
              as File,
    ));
  }
}

/// @nodoc

class _$SpeeckToTextImpl implements SpeeckToText {
  const _$SpeeckToTextImpl(this.file);

  @override
  final File file;

  @override
  String toString() {
    return 'PresentingEvent.speechToText(file: $file)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SpeeckToTextImpl &&
            (identical(other.file, file) || other.file == file));
  }

  @override
  int get hashCode => Object.hash(runtimeType, file);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SpeeckToTextImplCopyWith<_$SpeeckToTextImpl> get copyWith =>
      __$$SpeeckToTextImplCopyWithImpl<_$SpeeckToTextImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() showMessage,
    required TResult Function(File file) speechToText,
    required TResult Function(String audio, String language) textToSpeech,
    required TResult Function() syncSensorStatus,
    required TResult Function(List<PositionEntity> positions) initWaypoints,
    required TResult Function() continueTask,
    required TResult Function() cancelTask,
    required TResult Function() pauseTask,
    required TResult Function() nextTask,
  }) {
    return speechToText(file);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? showMessage,
    TResult? Function(File file)? speechToText,
    TResult? Function(String audio, String language)? textToSpeech,
    TResult? Function()? syncSensorStatus,
    TResult? Function(List<PositionEntity> positions)? initWaypoints,
    TResult? Function()? continueTask,
    TResult? Function()? cancelTask,
    TResult? Function()? pauseTask,
    TResult? Function()? nextTask,
  }) {
    return speechToText?.call(file);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? showMessage,
    TResult Function(File file)? speechToText,
    TResult Function(String audio, String language)? textToSpeech,
    TResult Function()? syncSensorStatus,
    TResult Function(List<PositionEntity> positions)? initWaypoints,
    TResult Function()? continueTask,
    TResult Function()? cancelTask,
    TResult Function()? pauseTask,
    TResult Function()? nextTask,
    required TResult orElse(),
  }) {
    if (speechToText != null) {
      return speechToText(file);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ShowMessage value) showMessage,
    required TResult Function(SpeeckToText value) speechToText,
    required TResult Function(TextToSpeech value) textToSpeech,
    required TResult Function(SyncSensorStatus value) syncSensorStatus,
    required TResult Function(OnInitWaypoints value) initWaypoints,
    required TResult Function(OnContinueTask value) continueTask,
    required TResult Function(OnCancelTask value) cancelTask,
    required TResult Function(OnPauseTask value) pauseTask,
    required TResult Function(OnNextTask value) nextTask,
  }) {
    return speechToText(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ShowMessage value)? showMessage,
    TResult? Function(SpeeckToText value)? speechToText,
    TResult? Function(TextToSpeech value)? textToSpeech,
    TResult? Function(SyncSensorStatus value)? syncSensorStatus,
    TResult? Function(OnInitWaypoints value)? initWaypoints,
    TResult? Function(OnContinueTask value)? continueTask,
    TResult? Function(OnCancelTask value)? cancelTask,
    TResult? Function(OnPauseTask value)? pauseTask,
    TResult? Function(OnNextTask value)? nextTask,
  }) {
    return speechToText?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ShowMessage value)? showMessage,
    TResult Function(SpeeckToText value)? speechToText,
    TResult Function(TextToSpeech value)? textToSpeech,
    TResult Function(SyncSensorStatus value)? syncSensorStatus,
    TResult Function(OnInitWaypoints value)? initWaypoints,
    TResult Function(OnContinueTask value)? continueTask,
    TResult Function(OnCancelTask value)? cancelTask,
    TResult Function(OnPauseTask value)? pauseTask,
    TResult Function(OnNextTask value)? nextTask,
    required TResult orElse(),
  }) {
    if (speechToText != null) {
      return speechToText(this);
    }
    return orElse();
  }
}

abstract class SpeeckToText implements PresentingEvent {
  const factory SpeeckToText(final File file) = _$SpeeckToTextImpl;

  File get file;
  @JsonKey(ignore: true)
  _$$SpeeckToTextImplCopyWith<_$SpeeckToTextImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TextToSpeechImplCopyWith<$Res> {
  factory _$$TextToSpeechImplCopyWith(
          _$TextToSpeechImpl value, $Res Function(_$TextToSpeechImpl) then) =
      __$$TextToSpeechImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String audio, String language});
}

/// @nodoc
class __$$TextToSpeechImplCopyWithImpl<$Res>
    extends _$PresentingEventCopyWithImpl<$Res, _$TextToSpeechImpl>
    implements _$$TextToSpeechImplCopyWith<$Res> {
  __$$TextToSpeechImplCopyWithImpl(
      _$TextToSpeechImpl _value, $Res Function(_$TextToSpeechImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? audio = null,
    Object? language = null,
  }) {
    return _then(_$TextToSpeechImpl(
      null == audio
          ? _value.audio
          : audio // ignore: cast_nullable_to_non_nullable
              as String,
      null == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$TextToSpeechImpl implements TextToSpeech {
  const _$TextToSpeechImpl(this.audio, this.language);

  @override
  final String audio;
  @override
  final String language;

  @override
  String toString() {
    return 'PresentingEvent.textToSpeech(audio: $audio, language: $language)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TextToSpeechImpl &&
            (identical(other.audio, audio) || other.audio == audio) &&
            (identical(other.language, language) ||
                other.language == language));
  }

  @override
  int get hashCode => Object.hash(runtimeType, audio, language);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TextToSpeechImplCopyWith<_$TextToSpeechImpl> get copyWith =>
      __$$TextToSpeechImplCopyWithImpl<_$TextToSpeechImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() showMessage,
    required TResult Function(File file) speechToText,
    required TResult Function(String audio, String language) textToSpeech,
    required TResult Function() syncSensorStatus,
    required TResult Function(List<PositionEntity> positions) initWaypoints,
    required TResult Function() continueTask,
    required TResult Function() cancelTask,
    required TResult Function() pauseTask,
    required TResult Function() nextTask,
  }) {
    return textToSpeech(audio, language);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? showMessage,
    TResult? Function(File file)? speechToText,
    TResult? Function(String audio, String language)? textToSpeech,
    TResult? Function()? syncSensorStatus,
    TResult? Function(List<PositionEntity> positions)? initWaypoints,
    TResult? Function()? continueTask,
    TResult? Function()? cancelTask,
    TResult? Function()? pauseTask,
    TResult? Function()? nextTask,
  }) {
    return textToSpeech?.call(audio, language);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? showMessage,
    TResult Function(File file)? speechToText,
    TResult Function(String audio, String language)? textToSpeech,
    TResult Function()? syncSensorStatus,
    TResult Function(List<PositionEntity> positions)? initWaypoints,
    TResult Function()? continueTask,
    TResult Function()? cancelTask,
    TResult Function()? pauseTask,
    TResult Function()? nextTask,
    required TResult orElse(),
  }) {
    if (textToSpeech != null) {
      return textToSpeech(audio, language);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ShowMessage value) showMessage,
    required TResult Function(SpeeckToText value) speechToText,
    required TResult Function(TextToSpeech value) textToSpeech,
    required TResult Function(SyncSensorStatus value) syncSensorStatus,
    required TResult Function(OnInitWaypoints value) initWaypoints,
    required TResult Function(OnContinueTask value) continueTask,
    required TResult Function(OnCancelTask value) cancelTask,
    required TResult Function(OnPauseTask value) pauseTask,
    required TResult Function(OnNextTask value) nextTask,
  }) {
    return textToSpeech(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ShowMessage value)? showMessage,
    TResult? Function(SpeeckToText value)? speechToText,
    TResult? Function(TextToSpeech value)? textToSpeech,
    TResult? Function(SyncSensorStatus value)? syncSensorStatus,
    TResult? Function(OnInitWaypoints value)? initWaypoints,
    TResult? Function(OnContinueTask value)? continueTask,
    TResult? Function(OnCancelTask value)? cancelTask,
    TResult? Function(OnPauseTask value)? pauseTask,
    TResult? Function(OnNextTask value)? nextTask,
  }) {
    return textToSpeech?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ShowMessage value)? showMessage,
    TResult Function(SpeeckToText value)? speechToText,
    TResult Function(TextToSpeech value)? textToSpeech,
    TResult Function(SyncSensorStatus value)? syncSensorStatus,
    TResult Function(OnInitWaypoints value)? initWaypoints,
    TResult Function(OnContinueTask value)? continueTask,
    TResult Function(OnCancelTask value)? cancelTask,
    TResult Function(OnPauseTask value)? pauseTask,
    TResult Function(OnNextTask value)? nextTask,
    required TResult orElse(),
  }) {
    if (textToSpeech != null) {
      return textToSpeech(this);
    }
    return orElse();
  }
}

abstract class TextToSpeech implements PresentingEvent {
  const factory TextToSpeech(final String audio, final String language) =
      _$TextToSpeechImpl;

  String get audio;
  String get language;
  @JsonKey(ignore: true)
  _$$TextToSpeechImplCopyWith<_$TextToSpeechImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SyncSensorStatusImplCopyWith<$Res> {
  factory _$$SyncSensorStatusImplCopyWith(_$SyncSensorStatusImpl value,
          $Res Function(_$SyncSensorStatusImpl) then) =
      __$$SyncSensorStatusImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SyncSensorStatusImplCopyWithImpl<$Res>
    extends _$PresentingEventCopyWithImpl<$Res, _$SyncSensorStatusImpl>
    implements _$$SyncSensorStatusImplCopyWith<$Res> {
  __$$SyncSensorStatusImplCopyWithImpl(_$SyncSensorStatusImpl _value,
      $Res Function(_$SyncSensorStatusImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SyncSensorStatusImpl implements SyncSensorStatus {
  const _$SyncSensorStatusImpl();

  @override
  String toString() {
    return 'PresentingEvent.syncSensorStatus()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SyncSensorStatusImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() showMessage,
    required TResult Function(File file) speechToText,
    required TResult Function(String audio, String language) textToSpeech,
    required TResult Function() syncSensorStatus,
    required TResult Function(List<PositionEntity> positions) initWaypoints,
    required TResult Function() continueTask,
    required TResult Function() cancelTask,
    required TResult Function() pauseTask,
    required TResult Function() nextTask,
  }) {
    return syncSensorStatus();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? showMessage,
    TResult? Function(File file)? speechToText,
    TResult? Function(String audio, String language)? textToSpeech,
    TResult? Function()? syncSensorStatus,
    TResult? Function(List<PositionEntity> positions)? initWaypoints,
    TResult? Function()? continueTask,
    TResult? Function()? cancelTask,
    TResult? Function()? pauseTask,
    TResult? Function()? nextTask,
  }) {
    return syncSensorStatus?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? showMessage,
    TResult Function(File file)? speechToText,
    TResult Function(String audio, String language)? textToSpeech,
    TResult Function()? syncSensorStatus,
    TResult Function(List<PositionEntity> positions)? initWaypoints,
    TResult Function()? continueTask,
    TResult Function()? cancelTask,
    TResult Function()? pauseTask,
    TResult Function()? nextTask,
    required TResult orElse(),
  }) {
    if (syncSensorStatus != null) {
      return syncSensorStatus();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ShowMessage value) showMessage,
    required TResult Function(SpeeckToText value) speechToText,
    required TResult Function(TextToSpeech value) textToSpeech,
    required TResult Function(SyncSensorStatus value) syncSensorStatus,
    required TResult Function(OnInitWaypoints value) initWaypoints,
    required TResult Function(OnContinueTask value) continueTask,
    required TResult Function(OnCancelTask value) cancelTask,
    required TResult Function(OnPauseTask value) pauseTask,
    required TResult Function(OnNextTask value) nextTask,
  }) {
    return syncSensorStatus(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ShowMessage value)? showMessage,
    TResult? Function(SpeeckToText value)? speechToText,
    TResult? Function(TextToSpeech value)? textToSpeech,
    TResult? Function(SyncSensorStatus value)? syncSensorStatus,
    TResult? Function(OnInitWaypoints value)? initWaypoints,
    TResult? Function(OnContinueTask value)? continueTask,
    TResult? Function(OnCancelTask value)? cancelTask,
    TResult? Function(OnPauseTask value)? pauseTask,
    TResult? Function(OnNextTask value)? nextTask,
  }) {
    return syncSensorStatus?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ShowMessage value)? showMessage,
    TResult Function(SpeeckToText value)? speechToText,
    TResult Function(TextToSpeech value)? textToSpeech,
    TResult Function(SyncSensorStatus value)? syncSensorStatus,
    TResult Function(OnInitWaypoints value)? initWaypoints,
    TResult Function(OnContinueTask value)? continueTask,
    TResult Function(OnCancelTask value)? cancelTask,
    TResult Function(OnPauseTask value)? pauseTask,
    TResult Function(OnNextTask value)? nextTask,
    required TResult orElse(),
  }) {
    if (syncSensorStatus != null) {
      return syncSensorStatus(this);
    }
    return orElse();
  }
}

abstract class SyncSensorStatus implements PresentingEvent {
  const factory SyncSensorStatus() = _$SyncSensorStatusImpl;
}

/// @nodoc
abstract class _$$OnInitWaypointsImplCopyWith<$Res> {
  factory _$$OnInitWaypointsImplCopyWith(_$OnInitWaypointsImpl value,
          $Res Function(_$OnInitWaypointsImpl) then) =
      __$$OnInitWaypointsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<PositionEntity> positions});
}

/// @nodoc
class __$$OnInitWaypointsImplCopyWithImpl<$Res>
    extends _$PresentingEventCopyWithImpl<$Res, _$OnInitWaypointsImpl>
    implements _$$OnInitWaypointsImplCopyWith<$Res> {
  __$$OnInitWaypointsImplCopyWithImpl(
      _$OnInitWaypointsImpl _value, $Res Function(_$OnInitWaypointsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? positions = null,
  }) {
    return _then(_$OnInitWaypointsImpl(
      null == positions
          ? _value._positions
          : positions // ignore: cast_nullable_to_non_nullable
              as List<PositionEntity>,
    ));
  }
}

/// @nodoc

class _$OnInitWaypointsImpl implements OnInitWaypoints {
  const _$OnInitWaypointsImpl(final List<PositionEntity> positions)
      : _positions = positions;

  final List<PositionEntity> _positions;
  @override
  List<PositionEntity> get positions {
    if (_positions is EqualUnmodifiableListView) return _positions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_positions);
  }

  @override
  String toString() {
    return 'PresentingEvent.initWaypoints(positions: $positions)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OnInitWaypointsImpl &&
            const DeepCollectionEquality()
                .equals(other._positions, _positions));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_positions));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$OnInitWaypointsImplCopyWith<_$OnInitWaypointsImpl> get copyWith =>
      __$$OnInitWaypointsImplCopyWithImpl<_$OnInitWaypointsImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() showMessage,
    required TResult Function(File file) speechToText,
    required TResult Function(String audio, String language) textToSpeech,
    required TResult Function() syncSensorStatus,
    required TResult Function(List<PositionEntity> positions) initWaypoints,
    required TResult Function() continueTask,
    required TResult Function() cancelTask,
    required TResult Function() pauseTask,
    required TResult Function() nextTask,
  }) {
    return initWaypoints(positions);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? showMessage,
    TResult? Function(File file)? speechToText,
    TResult? Function(String audio, String language)? textToSpeech,
    TResult? Function()? syncSensorStatus,
    TResult? Function(List<PositionEntity> positions)? initWaypoints,
    TResult? Function()? continueTask,
    TResult? Function()? cancelTask,
    TResult? Function()? pauseTask,
    TResult? Function()? nextTask,
  }) {
    return initWaypoints?.call(positions);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? showMessage,
    TResult Function(File file)? speechToText,
    TResult Function(String audio, String language)? textToSpeech,
    TResult Function()? syncSensorStatus,
    TResult Function(List<PositionEntity> positions)? initWaypoints,
    TResult Function()? continueTask,
    TResult Function()? cancelTask,
    TResult Function()? pauseTask,
    TResult Function()? nextTask,
    required TResult orElse(),
  }) {
    if (initWaypoints != null) {
      return initWaypoints(positions);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ShowMessage value) showMessage,
    required TResult Function(SpeeckToText value) speechToText,
    required TResult Function(TextToSpeech value) textToSpeech,
    required TResult Function(SyncSensorStatus value) syncSensorStatus,
    required TResult Function(OnInitWaypoints value) initWaypoints,
    required TResult Function(OnContinueTask value) continueTask,
    required TResult Function(OnCancelTask value) cancelTask,
    required TResult Function(OnPauseTask value) pauseTask,
    required TResult Function(OnNextTask value) nextTask,
  }) {
    return initWaypoints(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ShowMessage value)? showMessage,
    TResult? Function(SpeeckToText value)? speechToText,
    TResult? Function(TextToSpeech value)? textToSpeech,
    TResult? Function(SyncSensorStatus value)? syncSensorStatus,
    TResult? Function(OnInitWaypoints value)? initWaypoints,
    TResult? Function(OnContinueTask value)? continueTask,
    TResult? Function(OnCancelTask value)? cancelTask,
    TResult? Function(OnPauseTask value)? pauseTask,
    TResult? Function(OnNextTask value)? nextTask,
  }) {
    return initWaypoints?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ShowMessage value)? showMessage,
    TResult Function(SpeeckToText value)? speechToText,
    TResult Function(TextToSpeech value)? textToSpeech,
    TResult Function(SyncSensorStatus value)? syncSensorStatus,
    TResult Function(OnInitWaypoints value)? initWaypoints,
    TResult Function(OnContinueTask value)? continueTask,
    TResult Function(OnCancelTask value)? cancelTask,
    TResult Function(OnPauseTask value)? pauseTask,
    TResult Function(OnNextTask value)? nextTask,
    required TResult orElse(),
  }) {
    if (initWaypoints != null) {
      return initWaypoints(this);
    }
    return orElse();
  }
}

abstract class OnInitWaypoints implements PresentingEvent {
  const factory OnInitWaypoints(final List<PositionEntity> positions) =
      _$OnInitWaypointsImpl;

  List<PositionEntity> get positions;
  @JsonKey(ignore: true)
  _$$OnInitWaypointsImplCopyWith<_$OnInitWaypointsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$OnContinueTaskImplCopyWith<$Res> {
  factory _$$OnContinueTaskImplCopyWith(_$OnContinueTaskImpl value,
          $Res Function(_$OnContinueTaskImpl) then) =
      __$$OnContinueTaskImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OnContinueTaskImplCopyWithImpl<$Res>
    extends _$PresentingEventCopyWithImpl<$Res, _$OnContinueTaskImpl>
    implements _$$OnContinueTaskImplCopyWith<$Res> {
  __$$OnContinueTaskImplCopyWithImpl(
      _$OnContinueTaskImpl _value, $Res Function(_$OnContinueTaskImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$OnContinueTaskImpl implements OnContinueTask {
  const _$OnContinueTaskImpl();

  @override
  String toString() {
    return 'PresentingEvent.continueTask()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$OnContinueTaskImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() showMessage,
    required TResult Function(File file) speechToText,
    required TResult Function(String audio, String language) textToSpeech,
    required TResult Function() syncSensorStatus,
    required TResult Function(List<PositionEntity> positions) initWaypoints,
    required TResult Function() continueTask,
    required TResult Function() cancelTask,
    required TResult Function() pauseTask,
    required TResult Function() nextTask,
  }) {
    return continueTask();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? showMessage,
    TResult? Function(File file)? speechToText,
    TResult? Function(String audio, String language)? textToSpeech,
    TResult? Function()? syncSensorStatus,
    TResult? Function(List<PositionEntity> positions)? initWaypoints,
    TResult? Function()? continueTask,
    TResult? Function()? cancelTask,
    TResult? Function()? pauseTask,
    TResult? Function()? nextTask,
  }) {
    return continueTask?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? showMessage,
    TResult Function(File file)? speechToText,
    TResult Function(String audio, String language)? textToSpeech,
    TResult Function()? syncSensorStatus,
    TResult Function(List<PositionEntity> positions)? initWaypoints,
    TResult Function()? continueTask,
    TResult Function()? cancelTask,
    TResult Function()? pauseTask,
    TResult Function()? nextTask,
    required TResult orElse(),
  }) {
    if (continueTask != null) {
      return continueTask();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ShowMessage value) showMessage,
    required TResult Function(SpeeckToText value) speechToText,
    required TResult Function(TextToSpeech value) textToSpeech,
    required TResult Function(SyncSensorStatus value) syncSensorStatus,
    required TResult Function(OnInitWaypoints value) initWaypoints,
    required TResult Function(OnContinueTask value) continueTask,
    required TResult Function(OnCancelTask value) cancelTask,
    required TResult Function(OnPauseTask value) pauseTask,
    required TResult Function(OnNextTask value) nextTask,
  }) {
    return continueTask(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ShowMessage value)? showMessage,
    TResult? Function(SpeeckToText value)? speechToText,
    TResult? Function(TextToSpeech value)? textToSpeech,
    TResult? Function(SyncSensorStatus value)? syncSensorStatus,
    TResult? Function(OnInitWaypoints value)? initWaypoints,
    TResult? Function(OnContinueTask value)? continueTask,
    TResult? Function(OnCancelTask value)? cancelTask,
    TResult? Function(OnPauseTask value)? pauseTask,
    TResult? Function(OnNextTask value)? nextTask,
  }) {
    return continueTask?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ShowMessage value)? showMessage,
    TResult Function(SpeeckToText value)? speechToText,
    TResult Function(TextToSpeech value)? textToSpeech,
    TResult Function(SyncSensorStatus value)? syncSensorStatus,
    TResult Function(OnInitWaypoints value)? initWaypoints,
    TResult Function(OnContinueTask value)? continueTask,
    TResult Function(OnCancelTask value)? cancelTask,
    TResult Function(OnPauseTask value)? pauseTask,
    TResult Function(OnNextTask value)? nextTask,
    required TResult orElse(),
  }) {
    if (continueTask != null) {
      return continueTask(this);
    }
    return orElse();
  }
}

abstract class OnContinueTask implements PresentingEvent {
  const factory OnContinueTask() = _$OnContinueTaskImpl;
}

/// @nodoc
abstract class _$$OnCancelTaskImplCopyWith<$Res> {
  factory _$$OnCancelTaskImplCopyWith(
          _$OnCancelTaskImpl value, $Res Function(_$OnCancelTaskImpl) then) =
      __$$OnCancelTaskImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OnCancelTaskImplCopyWithImpl<$Res>
    extends _$PresentingEventCopyWithImpl<$Res, _$OnCancelTaskImpl>
    implements _$$OnCancelTaskImplCopyWith<$Res> {
  __$$OnCancelTaskImplCopyWithImpl(
      _$OnCancelTaskImpl _value, $Res Function(_$OnCancelTaskImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$OnCancelTaskImpl implements OnCancelTask {
  const _$OnCancelTaskImpl();

  @override
  String toString() {
    return 'PresentingEvent.cancelTask()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$OnCancelTaskImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() showMessage,
    required TResult Function(File file) speechToText,
    required TResult Function(String audio, String language) textToSpeech,
    required TResult Function() syncSensorStatus,
    required TResult Function(List<PositionEntity> positions) initWaypoints,
    required TResult Function() continueTask,
    required TResult Function() cancelTask,
    required TResult Function() pauseTask,
    required TResult Function() nextTask,
  }) {
    return cancelTask();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? showMessage,
    TResult? Function(File file)? speechToText,
    TResult? Function(String audio, String language)? textToSpeech,
    TResult? Function()? syncSensorStatus,
    TResult? Function(List<PositionEntity> positions)? initWaypoints,
    TResult? Function()? continueTask,
    TResult? Function()? cancelTask,
    TResult? Function()? pauseTask,
    TResult? Function()? nextTask,
  }) {
    return cancelTask?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? showMessage,
    TResult Function(File file)? speechToText,
    TResult Function(String audio, String language)? textToSpeech,
    TResult Function()? syncSensorStatus,
    TResult Function(List<PositionEntity> positions)? initWaypoints,
    TResult Function()? continueTask,
    TResult Function()? cancelTask,
    TResult Function()? pauseTask,
    TResult Function()? nextTask,
    required TResult orElse(),
  }) {
    if (cancelTask != null) {
      return cancelTask();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ShowMessage value) showMessage,
    required TResult Function(SpeeckToText value) speechToText,
    required TResult Function(TextToSpeech value) textToSpeech,
    required TResult Function(SyncSensorStatus value) syncSensorStatus,
    required TResult Function(OnInitWaypoints value) initWaypoints,
    required TResult Function(OnContinueTask value) continueTask,
    required TResult Function(OnCancelTask value) cancelTask,
    required TResult Function(OnPauseTask value) pauseTask,
    required TResult Function(OnNextTask value) nextTask,
  }) {
    return cancelTask(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ShowMessage value)? showMessage,
    TResult? Function(SpeeckToText value)? speechToText,
    TResult? Function(TextToSpeech value)? textToSpeech,
    TResult? Function(SyncSensorStatus value)? syncSensorStatus,
    TResult? Function(OnInitWaypoints value)? initWaypoints,
    TResult? Function(OnContinueTask value)? continueTask,
    TResult? Function(OnCancelTask value)? cancelTask,
    TResult? Function(OnPauseTask value)? pauseTask,
    TResult? Function(OnNextTask value)? nextTask,
  }) {
    return cancelTask?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ShowMessage value)? showMessage,
    TResult Function(SpeeckToText value)? speechToText,
    TResult Function(TextToSpeech value)? textToSpeech,
    TResult Function(SyncSensorStatus value)? syncSensorStatus,
    TResult Function(OnInitWaypoints value)? initWaypoints,
    TResult Function(OnContinueTask value)? continueTask,
    TResult Function(OnCancelTask value)? cancelTask,
    TResult Function(OnPauseTask value)? pauseTask,
    TResult Function(OnNextTask value)? nextTask,
    required TResult orElse(),
  }) {
    if (cancelTask != null) {
      return cancelTask(this);
    }
    return orElse();
  }
}

abstract class OnCancelTask implements PresentingEvent {
  const factory OnCancelTask() = _$OnCancelTaskImpl;
}

/// @nodoc
abstract class _$$OnPauseTaskImplCopyWith<$Res> {
  factory _$$OnPauseTaskImplCopyWith(
          _$OnPauseTaskImpl value, $Res Function(_$OnPauseTaskImpl) then) =
      __$$OnPauseTaskImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OnPauseTaskImplCopyWithImpl<$Res>
    extends _$PresentingEventCopyWithImpl<$Res, _$OnPauseTaskImpl>
    implements _$$OnPauseTaskImplCopyWith<$Res> {
  __$$OnPauseTaskImplCopyWithImpl(
      _$OnPauseTaskImpl _value, $Res Function(_$OnPauseTaskImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$OnPauseTaskImpl implements OnPauseTask {
  const _$OnPauseTaskImpl();

  @override
  String toString() {
    return 'PresentingEvent.pauseTask()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$OnPauseTaskImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() showMessage,
    required TResult Function(File file) speechToText,
    required TResult Function(String audio, String language) textToSpeech,
    required TResult Function() syncSensorStatus,
    required TResult Function(List<PositionEntity> positions) initWaypoints,
    required TResult Function() continueTask,
    required TResult Function() cancelTask,
    required TResult Function() pauseTask,
    required TResult Function() nextTask,
  }) {
    return pauseTask();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? showMessage,
    TResult? Function(File file)? speechToText,
    TResult? Function(String audio, String language)? textToSpeech,
    TResult? Function()? syncSensorStatus,
    TResult? Function(List<PositionEntity> positions)? initWaypoints,
    TResult? Function()? continueTask,
    TResult? Function()? cancelTask,
    TResult? Function()? pauseTask,
    TResult? Function()? nextTask,
  }) {
    return pauseTask?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? showMessage,
    TResult Function(File file)? speechToText,
    TResult Function(String audio, String language)? textToSpeech,
    TResult Function()? syncSensorStatus,
    TResult Function(List<PositionEntity> positions)? initWaypoints,
    TResult Function()? continueTask,
    TResult Function()? cancelTask,
    TResult Function()? pauseTask,
    TResult Function()? nextTask,
    required TResult orElse(),
  }) {
    if (pauseTask != null) {
      return pauseTask();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ShowMessage value) showMessage,
    required TResult Function(SpeeckToText value) speechToText,
    required TResult Function(TextToSpeech value) textToSpeech,
    required TResult Function(SyncSensorStatus value) syncSensorStatus,
    required TResult Function(OnInitWaypoints value) initWaypoints,
    required TResult Function(OnContinueTask value) continueTask,
    required TResult Function(OnCancelTask value) cancelTask,
    required TResult Function(OnPauseTask value) pauseTask,
    required TResult Function(OnNextTask value) nextTask,
  }) {
    return pauseTask(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ShowMessage value)? showMessage,
    TResult? Function(SpeeckToText value)? speechToText,
    TResult? Function(TextToSpeech value)? textToSpeech,
    TResult? Function(SyncSensorStatus value)? syncSensorStatus,
    TResult? Function(OnInitWaypoints value)? initWaypoints,
    TResult? Function(OnContinueTask value)? continueTask,
    TResult? Function(OnCancelTask value)? cancelTask,
    TResult? Function(OnPauseTask value)? pauseTask,
    TResult? Function(OnNextTask value)? nextTask,
  }) {
    return pauseTask?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ShowMessage value)? showMessage,
    TResult Function(SpeeckToText value)? speechToText,
    TResult Function(TextToSpeech value)? textToSpeech,
    TResult Function(SyncSensorStatus value)? syncSensorStatus,
    TResult Function(OnInitWaypoints value)? initWaypoints,
    TResult Function(OnContinueTask value)? continueTask,
    TResult Function(OnCancelTask value)? cancelTask,
    TResult Function(OnPauseTask value)? pauseTask,
    TResult Function(OnNextTask value)? nextTask,
    required TResult orElse(),
  }) {
    if (pauseTask != null) {
      return pauseTask(this);
    }
    return orElse();
  }
}

abstract class OnPauseTask implements PresentingEvent {
  const factory OnPauseTask() = _$OnPauseTaskImpl;
}

/// @nodoc
abstract class _$$OnNextTaskImplCopyWith<$Res> {
  factory _$$OnNextTaskImplCopyWith(
          _$OnNextTaskImpl value, $Res Function(_$OnNextTaskImpl) then) =
      __$$OnNextTaskImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OnNextTaskImplCopyWithImpl<$Res>
    extends _$PresentingEventCopyWithImpl<$Res, _$OnNextTaskImpl>
    implements _$$OnNextTaskImplCopyWith<$Res> {
  __$$OnNextTaskImplCopyWithImpl(
      _$OnNextTaskImpl _value, $Res Function(_$OnNextTaskImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$OnNextTaskImpl implements OnNextTask {
  const _$OnNextTaskImpl();

  @override
  String toString() {
    return 'PresentingEvent.nextTask()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$OnNextTaskImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() showMessage,
    required TResult Function(File file) speechToText,
    required TResult Function(String audio, String language) textToSpeech,
    required TResult Function() syncSensorStatus,
    required TResult Function(List<PositionEntity> positions) initWaypoints,
    required TResult Function() continueTask,
    required TResult Function() cancelTask,
    required TResult Function() pauseTask,
    required TResult Function() nextTask,
  }) {
    return nextTask();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? showMessage,
    TResult? Function(File file)? speechToText,
    TResult? Function(String audio, String language)? textToSpeech,
    TResult? Function()? syncSensorStatus,
    TResult? Function(List<PositionEntity> positions)? initWaypoints,
    TResult? Function()? continueTask,
    TResult? Function()? cancelTask,
    TResult? Function()? pauseTask,
    TResult? Function()? nextTask,
  }) {
    return nextTask?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? showMessage,
    TResult Function(File file)? speechToText,
    TResult Function(String audio, String language)? textToSpeech,
    TResult Function()? syncSensorStatus,
    TResult Function(List<PositionEntity> positions)? initWaypoints,
    TResult Function()? continueTask,
    TResult Function()? cancelTask,
    TResult Function()? pauseTask,
    TResult Function()? nextTask,
    required TResult orElse(),
  }) {
    if (nextTask != null) {
      return nextTask();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ShowMessage value) showMessage,
    required TResult Function(SpeeckToText value) speechToText,
    required TResult Function(TextToSpeech value) textToSpeech,
    required TResult Function(SyncSensorStatus value) syncSensorStatus,
    required TResult Function(OnInitWaypoints value) initWaypoints,
    required TResult Function(OnContinueTask value) continueTask,
    required TResult Function(OnCancelTask value) cancelTask,
    required TResult Function(OnPauseTask value) pauseTask,
    required TResult Function(OnNextTask value) nextTask,
  }) {
    return nextTask(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ShowMessage value)? showMessage,
    TResult? Function(SpeeckToText value)? speechToText,
    TResult? Function(TextToSpeech value)? textToSpeech,
    TResult? Function(SyncSensorStatus value)? syncSensorStatus,
    TResult? Function(OnInitWaypoints value)? initWaypoints,
    TResult? Function(OnContinueTask value)? continueTask,
    TResult? Function(OnCancelTask value)? cancelTask,
    TResult? Function(OnPauseTask value)? pauseTask,
    TResult? Function(OnNextTask value)? nextTask,
  }) {
    return nextTask?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ShowMessage value)? showMessage,
    TResult Function(SpeeckToText value)? speechToText,
    TResult Function(TextToSpeech value)? textToSpeech,
    TResult Function(SyncSensorStatus value)? syncSensorStatus,
    TResult Function(OnInitWaypoints value)? initWaypoints,
    TResult Function(OnContinueTask value)? continueTask,
    TResult Function(OnCancelTask value)? cancelTask,
    TResult Function(OnPauseTask value)? pauseTask,
    TResult Function(OnNextTask value)? nextTask,
    required TResult orElse(),
  }) {
    if (nextTask != null) {
      return nextTask(this);
    }
    return orElse();
  }
}

abstract class OnNextTask implements PresentingEvent {
  const factory OnNextTask() = _$OnNextTaskImpl;
}
